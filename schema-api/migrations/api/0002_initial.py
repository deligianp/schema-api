# Generated by Django 5.0.4 on 2024-07-16 14:37

import django.db.models.deletion
import util.constraints
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('api', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='context',
            name='owner',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddField(
            model_name='env',
            name='executor',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='envs', to='api.executor'),
        ),
        migrations.AddField(
            model_name='executoroutputlog',
            name='executor',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='api.executor'),
        ),
        migrations.AddField(
            model_name='participation',
            name='context',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='api.context'),
        ),
        migrations.AddField(
            model_name='participation',
            name='user',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddField(
            model_name='task',
            name='context',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='api.context'),
        ),
        migrations.AddField(
            model_name='task',
            name='user',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddField(
            model_name='tag',
            name='task',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='tags', to='api.task'),
        ),
        migrations.AddField(
            model_name='resourceset',
            name='task',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='resources', to='api.task'),
        ),
        migrations.AddField(
            model_name='mountpoint',
            name='task',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='mount_points', to='api.task'),
        ),
        migrations.AddField(
            model_name='executor',
            name='task',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='executors', to='api.task'),
        ),
        migrations.AddField(
            model_name='volume',
            name='task',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='volumes', to='api.task'),
        ),
        migrations.AddConstraint(
            model_name='context',
            constraint=util.constraints.ApplicationUniqueConstraint(condition=models.Q(('owner__isnull', True)), error_context={'field': 'name'}, fields=('name',), name='context_name_unique', violation_error_message='Name is not available'),
        ),
        migrations.AddConstraint(
            model_name='context',
            constraint=util.constraints.ApplicationUniqueConstraint(condition=models.Q(('owner__isnull', False)), error_context={'field': 'name'}, fields=('name',), name='context_name_unique_per_child', violation_error_message='Name is not available'),
        ),
        migrations.AddConstraint(
            model_name='env',
            constraint=models.CheckConstraint(check=models.Q(('key__regex', '^\\s*$'), _negated=True), name='env_key_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='participation',
            constraint=util.constraints.ApplicationUniqueConstraint(error_context=None, fields=('user', 'context'), name='user_context_unique', violation_error_message='Referenced user is already a participant of the referenced context'),
        ),
        migrations.AddConstraint(
            model_name='task',
            constraint=models.CheckConstraint(check=models.Q(('name__regex', '^\\s*$'), _negated=True), name='name_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='task',
            constraint=models.CheckConstraint(check=models.Q(('status__in', ['SUBMITTED', 'APPROVED', 'REJECTED', 'SCHEDULED', 'INITIALIZING', 'RUNNING', 'ERROR', 'COMPLETED', 'UNKNOWN', 'CANCELED'])), name='status_enum'),
        ),
        migrations.AddConstraint(
            model_name='task',
            constraint=models.CheckConstraint(check=models.Q(models.Q(models.Q(('task_id__regex', '^\\s*$'), _negated=True), ('status', 'SUBMITTED'), ('status', 'REJECTED'), ('status', 'APPROVED'), _connector='OR')), name='scheduled_task_task_id_required'),
        ),
        migrations.AddConstraint(
            model_name='task',
            constraint=models.CheckConstraint(check=models.Q(models.Q(models.Q(models.Q(('status', 'CANCELED'), ('status', 'COMPLETED'), ('status', 'ERROR'), ('status', 'REJECTED'), _connector='OR'), ('pending', False)), models.Q(models.Q(('status', 'CANCELED'), _negated=True), models.Q(('status', 'COMPLETED'), _negated=True), models.Q(('status', 'ERROR'), _negated=True), models.Q(('status', 'REJECTED'), _negated=True), ('pending', True)), _connector='OR')), name='task_status_is_pending_integrity_check'),
        ),
        migrations.AddConstraint(
            model_name='task',
            constraint=models.CheckConstraint(check=models.Q(('submitted_at__lt', models.F('latest_update'))), name='update_after_task_submit'),
        ),
        migrations.AddConstraint(
            model_name='tag',
            constraint=models.CheckConstraint(check=models.Q(('key__regex', '^\\s*$'), _negated=True), name='tag_key_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='resourceset',
            constraint=models.CheckConstraint(check=models.Q(('cpu_cores__gt', 0)), name='cpu_cores_min'),
        ),
        migrations.AddConstraint(
            model_name='resourceset',
            constraint=models.CheckConstraint(check=models.Q(('ram_gb__gte', 0)), name='ram_gb_min'),
        ),
        migrations.AddConstraint(
            model_name='resourceset',
            constraint=models.CheckConstraint(check=models.Q(('disk_gb__gte', 0)), name='disk_gb_min'),
        ),
        migrations.AddConstraint(
            model_name='mountpoint',
            constraint=models.CheckConstraint(check=models.Q(models.Q(models.Q(('url__regex', '^\\s*$'), _negated=True), models.Q(('is_input', True), ('type', 'FILE')), _connector='OR')), name='url_missing_only_if_is_file', violation_error_message='Given: url:F(url), is_dir:F(is_dir), is_input:F(is_input)'),
        ),
        migrations.AddConstraint(
            model_name='mountpoint',
            constraint=models.CheckConstraint(check=models.Q(('path__regex', '^\\s*$'), _negated=True), name='container_path_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='mountpoint',
            constraint=models.CheckConstraint(check=models.Q(('type__in', ['FILE', 'DIRECTORY'])), name='mountpoint_type_enum'),
        ),
        migrations.AddConstraint(
            model_name='executor',
            constraint=models.CheckConstraint(check=models.Q(('image__regex', '^\\s*$'), _negated=True), name='image_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='executor',
            constraint=models.UniqueConstraint(fields=('task', 'order'), name='task_executor_order_unique'),
        ),
        migrations.AddConstraint(
            model_name='volume',
            constraint=models.CheckConstraint(check=models.Q(('path__regex', '^\\s*$'), _negated=True), name='path_not_empty'),
        ),
    ]
