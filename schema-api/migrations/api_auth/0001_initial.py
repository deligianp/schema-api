# Generated by Django 5.0.4 on 2024-07-16 14:37

import django.db.models.deletion
import django.utils.timezone
import util.constraints
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('api', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='AuthEntity',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('uuid', models.UUIDField(default=uuid.uuid4, unique=True)),
                ('username', models.CharField(max_length=20)),
                ('entity_type', models.CharField(choices=[('USER', 'User'), ('APPLICATION_SERVICE', 'Application service')], default='USER', max_length=32)),
                ('is_active', models.BooleanField(default=True)),
                ('is_superuser', models.BooleanField(default=False)),
                ('contexts', models.ManyToManyField(related_name='users', through='api.Participation', to='api.context')),
                ('parent', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='ApiToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(blank=True, max_length=255)),
                ('uuid', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('key', models.CharField(editable=False, max_length=8)),
                ('digest', models.CharField(editable=False, max_length=128)),
                ('created', models.DateTimeField(default=django.utils.timezone.now, editable=False)),
                ('expiry', models.DateTimeField()),
                ('is_active', models.BooleanField(default=True)),
                ('auth_entity', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('participation', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='api.participation')),
            ],
        ),
        migrations.CreateModel(
            name='UserProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fs_user_dir', models.CharField(blank=True, max_length=40)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='profile', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationUniqueConstraint(condition=models.Q(('parent__isnull', False)), error_context={'field': 'username'}, fields=('username', 'parent'), name='username_parent_unique_together', violation_error_message='Username is not available'),
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationUniqueConstraint(condition=models.Q(('parent__isnull', True)), error_context={'field': 'username'}, fields=('username',), name='username_unique_when_no_parent', violation_error_message='Username is not available'),
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('entity_type__in', ['USER', 'APPLICATION_SERVICE'])), error_context={'field': 'entity_type'}, name='entity_type_enum', violation_error_message='Type must be either of the following values: USER, APPLICATION_SERVICE'),
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('parent__isnull', True), ('entity_type', 'USER'), _connector='OR'), error_context={'field': 'entity_type'}, name='children_are_no_application_services', violation_error_message='Type cannot be APPLICATION_SERVICE when parent is not null'),
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('parent__isnull', True), ('is_superuser', False), _connector='OR'), error_context={'field': 'is_superuser'}, name='children_are_no_superusers', violation_error_message='Instance cannot represent a superuser when parent is not null'),
        ),
        migrations.AddConstraint(
            model_name='authentity',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('entity_type', 'APPLICATION_SERVICE'), ('is_superuser', True), _negated=True), error_context={'field': 'is_superuser'}, name='application_services_cannot_be_superusers', violation_error_message='An application service cannot be a superuser'),
        ),
        migrations.AddConstraint(
            model_name='apitoken',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(models.Q(('auth_entity__isnull', False), ('participation__isnull', True)), models.Q(('auth_entity__isnull', True), ('participation__isnull', False)), _connector='OR'), error_context=None, name='token_authenticates_either_user_or_participation', violation_error_message='Either auth_entity should be null or participation should be null'),
        ),
        migrations.AddConstraint(
            model_name='apitoken',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('created__lt', models.F('expiry'))), error_context={'field': 'expiry'}, name='expiry_after_creation', violation_error_message='Expiration date must be later than the creation date'),
        ),
        migrations.AddConstraint(
            model_name='userprofile',
            constraint=util.constraints.ApplicationCheckConstraint(check=models.Q(('fs_user_dir__regex', '^\\s*$'), _negated=True), error_context={'field': 'fs_user_dir'}, name='fs_user_dir_not_empty', violation_error_message='fs_user_dir cannot be empty'),
        ),
    ]
